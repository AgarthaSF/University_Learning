# Learning_switch

### 实现思路

在学习型交换机中，初始化时当前的表中的信息如果有更新，则向其所有邻居节点泛洪将这个信息传递出去。在传递过程中所有沿途节点都知道了要前往初始节点应向什么端口发送包裹，只要沿着路径传递时建立起的索引返回就能够返回初始节点。

在所有节点中存储一张一维路由表，标识从当前节点到目标地点应发送的端口。当节点接收到其他节点发送过来的包时，我们知道包的发送源以及其发送通过的端口，因此只要向该端口发包就能返回到包的发送源。当发送源不在路由表中时，将其端口信息存入一维表中，并向自己相邻的节点广播这一新信息。当初始化结束时，所有节点都知道了要前往某一节点应向哪个端口发包。

如果包要前往的目标地点已在路由表中，则直接向其对应端口发包。

需要注意的一点是我们所知晓的是前往`packet.src`而非前往`packet.dst`的端口。

# RIP_Router

### 实现思路

#### 概述

在每个节点中存储三个字典：

1. `sendPort   `：前往目标地点应通过的端口。
2. `distanceTable`：二维距离向量表，第一维代表要前往的地点，第二维代表邻居节点。
3. `currentShortest`：前往目标地点的当前最小距离。

首先需要明确几个概念：

1. 包裹只在相邻节点之间发送。
2. `packet.src`代表的就是邻居节点，而`packet.path`中存放的才应是目标地点。
3. RIP_Router不仅需要以路径最短发送到目标地点，且应能够处理断路情况。

#### 实现细节

处理包裹时先判断接收到的包的类型是`DiscoveryPacket`，`RoutingUpdate`还是`normalPacket`

- `DiscoveryPacket`

  - 如果包的链接正常建立

    如果包的源地址不在当前的端口表中，那么将其存入，并在二维路由表中将设为当前节点到达源地址的距离设为1，并将该信息存入`RoutingUpdate`包裹中泛洪发送。

  - 如果包的链接断开

    包的链接断开后需要更新表中信息，首先在端口表中寻找发送端口为当前端口的目标地点。因为端口表存储的是前往目标地点最佳路径的端口，而此时该端口到达包裹源地址的路径已经断开，所以将从源地址前往目标地址的距离更新为无穷大。

    如果断开的路径恰为最短路，且没有更新端口表，那么下次发包时仍走原端口包就发向了没有链接任何节点的地址，从而产生丢包。所以我们需要扫描距离向量表中每一维中的最小距离值，用最小值对应的邻居节点的端口更新当前的端口表。

- `RoutingUpdate`

  首先建立更新标识`updated`，代表在当前处理过程中是否产生了信息的更新，初始置为`False`，并建立一个新的更新包`updatePacket`。

  如果当前更新包中的目标地址还未存入距离表中，将其加入距离表中并更新最短路径值与端口值，将更新标识置为`True`，将信息存入`updatePacket`中。

  如果目标地址已存入距离表中，用更新包中到达目标地点距离，即`packet.src`到达`dest`的距离加上自身节点到达`packet.src`的距离就可计算出当前节点经过`packet.src`到达`dest`的距离。将计算结果存入距离向量表中。如果该距离小于当前到达目标距离的最小值，那么用计算距离替换该最小值，更新到达`dest`的端口号。将更新的信息存入`updatePacket`中，并将更新标识置为`True`。

  由于当网络中发生断路时最短路径可能会变大，如果最短路没有变小，那么检查其是否变大。如果变长，同样更新最短路，端口号，`updatePacket`与更新标识。

  如果更新标识为`True`，将`updatePacket`泛洪发送。

- `normalPacket`

  正常的包即为使用ping发送的包，在当前距离向量表中搜查拥有最小距离的邻居节点，将包裹向其端口发送过去。

